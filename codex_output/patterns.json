{
  "patterns": [
    {
      "patternId": "PAGINATION_CONTRACT",
<<<<<<< Updated upstream
      "tier": "CONTRACT",
      "version": "1.0.0",
      "purpose": "Normalize pagination math (page size clamps, cursor vs offset handling, summary copy) so every list view shares one Firestore-agnostic request/response format.",
=======
      "type": "contract",
      "version": "1.0.0",
      "purpose": "Normalize pagination math (page-size clamps, cursor/offset handling, summary copy) so every list view shares a datastore-agnostic request/response format.",
>>>>>>> Stashed changes
      "requiredParams": [
        "defaultPageSize"
      ],
      "optionalParams": [
        "minPageSize",
        "maxPageSize",
        "totalItems",
        "summaryTemplate"
      ],
      "adapters": {},
      "uiTexts": {
<<<<<<< Updated upstream
        "summaryTemplate": "Items {first}\u2013{last} of {total}"
      ],
      "a11yNotes": [
        "Outputs summaryText that downstream shells must announce via aria-live=polite so cursor math stays invisible to assistive tech.",
        "Surface prev/next disabled states derived from metadata so shells consistently wire aria-disabled."
      ],
      "requestShape": {
        "pageSize": "number // desired size before clamping",
        "direction": "'forward'|'backward' // defaults to forward",
        "cursorAfter?": "string|null // used when direction=forward",
        "cursorBefore?": "string|null // used when direction=backward",
        "offset?": "number // starting index for summary math",
        "filters?": "Record<string,string|number>// echoed by location helpers",
        "defaults?": "{ pageSize?: number, minPageSize?: number, maxPageSize?: number }"
      ],
      "resultShape": {
        "pageMeta": {
          "count": "number // items.length",
          "pageSize": "number",
          "hasNext": "boolean",
          "hasPrev": "boolean",
          "nextCursor?": "string|null",
          "prevCursor?": "string|null"
        },
        "summaryText": "string // e.g., Items 21\u201340 of 132",
        "prevDisabled": "boolean",
        "nextDisabled": "boolean",
        "totalItems?": "number",
        "currentOffset": "number",
        "filters": "Record<string,string>",
        "locationParams": "{ page: number, pageSize: number, offset: number, ...filters }"
      ],
      "publicAPI": [
        "createPaginationRequest(options)",
        "buildPaginationState(options)",
        "buildPaginationShellState(options)",
        "buildCatalogPaginationUi(options)",
        "buildPaginationLocationParams(options)",
        "parsePaginationFromLocation(options)"
      ],
=======
        "summaryTemplate": "Items {first}-{last} of {total}"
      },
      "a11yNotes": [
        "Outputs summaryText that downstream shells announce via aria-live=polite so cursor math stays invisible to assistive tech.",
        "Surface prev/next disabled states derived from metadata so shells consistently wire aria-disabled."
      ],
>>>>>>> Stashed changes
      "testBehaviors": [
        "Clamps requested pageSize between min/max/default values.",
        "Switches cursor usage automatically when direction changes.",
        "Normalizes hasNext/hasPrev booleans and null-safe cursors.",
        "Produces deterministic summaryText/disabled states for offsets at boundaries (first page, last page, empty).",
<<<<<<< Updated upstream
        "Serializes filters + pagination params into stable locationParams."
      ]
    },
    {
      "patternId": "PAGINATION_CONTROLLER",
      "tier": "CONTROLLER",
      "version": "1.0.0",
      "purpose": "State machine that talks to a dataSource, keeps cursors/offsets/filters/URL state in sync, and exposes a tiny API for shells (pager or load-more).",
=======
        "Serializes filters plus pagination params into stable locationParams."
      ],
      "docs": {
        "requestShape": {
          "pageSize": "number // desired size before clamping",
          "direction": "'forward'|'backward' // defaults to forward",
          "cursorAfter?": "string|null // used when direction=forward",
          "cursorBefore?": "string|null // used when direction=backward",
          "offset?": "number // starting index for summary math",
          "filters?": "Record<string,string|number>",
          "defaults?": "{ pageSize?: number, minPageSize?: number, maxPageSize?: number }"
        },
        "stateShape": {
          "pageMeta": "{ count: number, pageSize: number, hasNext: boolean, hasPrev: boolean, nextCursor?: string|null, prevCursor?: string|null }",
          "summaryText": "string",
          "prevDisabled": "boolean",
          "nextDisabled": "boolean",
          "totalItems?": "number",
          "currentOffset": "number",
          "filters": "Record<string,string>",
          "locationParams": "{ page: number, pageSize: number, offset: number, ...filters }"
        }
      }
    },
    {
      "patternId": "PAGINATION_CONTROLLER",
      "type": "controller",
      "version": "1.0.0",
      "purpose": "Promise-aware state machine that talks to a dataSource, keeps cursors/offsets/filters/URL state in sync, and exposes a small API for shells (pager or load-more).",
>>>>>>> Stashed changes
      "requiredParams": [
        "defaultPageSize"
      ],
      "optionalParams": [
        "mode",
        "initialFilters",
        "pageSizeOptions",
        "locationKey",
        "autoLoad",
        "loadMoreLimit"
      ],
      "adapters": {
        "dataSource": "({ request, filters, offset }) => Promise<{ items, pageMeta, totalItems?, offset?, currentOffset? }>",
        "parseLocation": "() => ({ pageSize?, direction?, cursorAfter?, cursorBefore?, offset?, filters? })",
        "syncLocation": "(params) => void",
        "onStateChange": "(state) => void"
<<<<<<< Updated upstream
      ],
      "uiTexts": {
        "summaryTemplate": "Items {first}\u2013{last} of {total}",
        "loadMoreLabel": "Load more ({nextFirst}\u2013{nextLast} of {total})"
      ],
      "a11yNotes": [
        "Expose `state.isLoading` so shells can toggle aria-busy and aria-disabled without their own timers.",
        "Ensure `state.currentPage`, `state.totalPages`, and `state.summaryText` are available for announcing context when page changes."
      ],
      "requestShape": {
        "pageSize": "number",
        "direction": "'forward'|'backward'|'absolute'",
        "cursorAfter?": "string|null",
        "cursorBefore?": "string|null",
        "offset?": "number",
        "filters?": "Record<string,string>"
      ],
      "resultShape": {
        "items": "any[]",
        "pageMeta": {
          "hasNext": "boolean",
          "hasPrev": "boolean",
          "nextCursor?": "string|null",
          "prevCursor?": "string|null",
          "pageSize": "number",
          "count": "number"
        },
        "totalItems?": "number",
        "currentOffset?": "number",
        "summaryText": "string",
        "prevDisabled": "boolean",
        "nextDisabled": "boolean",
        "isLoading": "boolean",
        "currentPage": "number",
        "totalPages": "number",
        "mode": "'pager'|'loadMore'"
      ],
      "publicAPI": [
        "getUiState()",
        "goNext()",
        "goPrev()",
        "goToPage(page)",
        "loadMore()",
        "setFilters(partialFilters)",
        "setPageSize(size)",
        "refresh()",
        "syncFromLocation({ search, totalItems })",
        "syncToLocation(updateFn)",
        "destroy()"
=======
      },
      "uiTexts": {
        "summaryTemplate": "Items {first}-{last} of {total}",
        "loadMoreLabel": "Load more ({nextFirst}-{nextLast} of {total})"
      },
      "a11yNotes": [
        "Expose state.isLoading so shells can toggle aria-busy and aria-disabled without their own timers.",
        "Ensure state.currentPage, state.totalPages, and state.summaryText are available for announcing context when page changes."
>>>>>>> Stashed changes
      ],
      "testBehaviors": [
        "Reads parseLocation() output before the first fetch to restore page/pageSize/filters.",
        "Clamps pageSize to provided options and resets to page 1 whenever page size or filters change.",
        "Drops stale cursors if offsets exceed totals and re-requests page 1.",
        "Ensures only the latest dataSource response mutates state (last-write-wins).",
        "Toggles isLoading/summary/disabled states in sync with goNext/goPrev/loadMore/setPageSize/setFilters."
<<<<<<< Updated upstream
      ]
    },
    {
      "patternId": "PAGINATION_SHELL",
      "tier": "SHELL",
=======
      ],
      "docs": {
        "requestShape": {
          "pageSize": "number",
          "direction": "'forward'|'backward'|'absolute'",
          "cursorAfter?": "string|null",
          "cursorBefore?": "string|null",
          "offset?": "number",
          "filters?": "Record<string,string>"
        },
        "stateShape": {
          "items": "any[]",
          "pageMeta": "{ hasNext: boolean, hasPrev: boolean, nextCursor?: string|null, prevCursor?: string|null, pageSize: number, count: number }",
          "totalItems?": "number",
          "currentOffset?": "number",
          "summaryText": "string",
          "prevDisabled": "boolean",
          "nextDisabled": "boolean",
          "isLoading": "boolean",
          "currentPage": "number",
          "totalPages": "number",
          "mode": "'pager'|'loadMore'"
        },
        "mountApi": "createPaginationController({ params, adapters, uiTexts, options }) => { getUiState, goNext, goPrev, goToPage, loadMore, setFilters, setPageSize, refresh, syncFromLocation, syncToLocation, destroy }"
      }
    },
    {
      "patternId": "PAGINATION_SHELL",
      "type": "shell",
>>>>>>> Stashed changes
      "version": "1.0.0",
      "purpose": "Declarative DOM wrapper (summary, Prev/Next, numeric pager, optional page-size select or load-more button) that consumes the pagination controller and standardizes markup/ARIA.",
      "requiredParams": [
        "container",
        "summaryEl",
        "prevButton",
        "nextButton"
      ],
      "optionalParams": [
        "pageSizeSelect",
        "pagesContainer",
        "mode",
        "sticky",
        "formatSummary"
      ],
      "adapters": {
<<<<<<< Updated upstream
        "controller": "Return value from PAGINATION_CONTROLLER.mount()",
        "formatSummary": "(summaryText, state) => string",
        "announce": "(text) => void // optional hook for custom SR messaging"
      ],
=======
        "controller": "Return value from PAGINATION_CONTROLLER.create()",
        "formatSummary": "(summaryText, state) => string",
        "announce": "(text) => void"
      },
>>>>>>> Stashed changes
      "uiTexts": {
        "prevLabel": "Previous page",
        "nextLabel": "Next page",
        "pageSizeLabel": "Rows per page",
        "loadMoreLabel": "Load more"
<<<<<<< Updated upstream
      ],
      "a11yNotes": [
        "summaryEl must be aria-live=polite; shell toggles container aria-busy when controller reports isLoading.",
=======
      },
      "a11yNotes": [
        "summaryEl must be aria-live=polite and the shell toggles container aria-busy when controller reports isLoading.",
>>>>>>> Stashed changes
        "Prev/Next buttons expose aria-disabled mirroring the disabled property.",
        "Numeric pager buttons set aria-current=\"page\" and include aria-label=\"Go to page N\"; ellipses are aria-hidden.",
        "Load-more button includes the upcoming range in its label for context."
      ],
<<<<<<< Updated upstream
      "requestShape": {
        "state": "controller.getUiState() payload used to sync DOM",
        "event": "'init'|'sync'|'teardown'",
        "elements": "{ container, summaryEl, prevButton, nextButton, pagesContainer?, pageSizeSelect? }"
      ],
      "resultShape": {
        "domUpdates": "Applies textContent/attributes/classes to supplied elements; no return value",
        "eventListeners": "{ prev:onClick, next:onClick, pageButton:onClick, pageSize:onChange, loadMore:onClick }",
        "teardown": "Removes listeners and aria attributes on destroy"
      ],
      "publicAPI": [
        "mount(config)",
        "sync()",
        "cleanup()"
      ],
      "testBehaviors": [
        "Disables Prev/Next buttons (and aria-disabled) whenever state.prevDisabled/state.nextDisabled or state.isBusy are true.",
=======
      "testBehaviors": [
        "Disables Prev/Next buttons (and aria-disabled) whenever state.prevDisabled/state.nextDisabled or state.isLoading are true.",
>>>>>>> Stashed changes
        "Numeric pager renders compressed ranges with ellipses and highlights current page.",
        "Changing the page-size select calls controller.setPageSize and re-syncs summary text.",
        "Load-more button calls controller.loadMore and updates summary copy once results arrive.",
        "Announces summary text updates via aria-live and keeps focus on activated buttons."
<<<<<<< Updated upstream
=======
      ],
      "docs": {
        "requestShape": {
          "state": "controller.getUiState() payload used to sync DOM",
          "event": "'init'|'sync'|'teardown'",
          "elements": "{ container, summaryEl, prevButton, nextButton, pagesContainer?, pageSizeSelect? }"
        },
        "stateShape": {
          "domUpdates": "Applies textContent/attributes/classes to supplied elements",
          "eventListeners": "{ prev:onClick, next:onClick, pageButton:onClick, pageSize:onChange, loadMore:onClick }"
        },
        "mountApi": "mountPaginationShell({ params, adapters, uiTexts, options }) => { sync, destroy }"
      }
    },
    {
      "patternId": "PAGINATION_SUITE",
      "type": "aggregate",
      "version": "1.0.0",
      "purpose": "End-to-end pagination package (contract + controller + shell) tuned for admin data grids and queues so adopters wire one factory and screen-specific adapters.",
      "requiredParams": [
        "container",
        "summaryEl",
        "prevButton",
        "nextButton",
        "defaultPageSize"
      ],
      "optionalParams": [
        "pageSizeOptions",
        "pagesContainer",
        "pageSizeSelect",
        "mode",
        "sticky",
        "locationKey",
        "loadMoreLimit"
      ],
      "adapters": {
        "dataSource": "({ request, filters, offset }) => Promise<{ items, pageMeta, totalItems?, offset?, currentOffset? }>",
        "parseLocation": "() => ({ pageSize?, direction?, cursorAfter?, cursorBefore?, offset?, filters? })",
        "syncLocation": "(params) => void",
        "onStateChange": "(state) => void",
        "announce": "(text) => void",
        "formatSummary": "(summaryText, state) => string"
      },
      "uiTexts": {
        "prevLabel": "Previous page",
        "nextLabel": "Next page",
        "pageSizeLabel": "Rows per page",
        "summaryTemplate": "Items {first}-{last} of {total}",
        "loadMoreLabel": "Load more"
      },
      "a11yNotes": [
        "Container toggles aria-busy while controller loads and summary remains aria-live=polite for every page change.",
        "Prev/Next/Load-more mirror disabled state plus aria-disabled; numeric pager buttons set aria-current and expose descriptive labels.",
        "Allows per-screen announce() hooks so high-volume queues can describe context (e.g., \"Bundles 21-40 of 210\")."
      ],
      "testBehaviors": [
        "Mounts controller+shell with one config and keeps them synchronized via onStateChange hooks.",
        "Propagates parseLocation() values before first fetch so reloads restore filters/page.",
        "Ensures adapter rejections bubble through onError/onStateChange without leaving stuck aria-busy states.",
        "Preserves pagination context when adopters mutate rows (publish/unpublish, marking fulfilled) and refetch only the impacted slice.",
        "Supports both pager and load-more modes with identical markup contracts so adopters swap modes via params only."
      ],
      "docs": {
        "requestShape": {
          "params": "{ defaultPageSize: number, mode?: 'pager'|'loadMore', pageSizeOptions?: number[], locationKey?: string }",
          "elements": "{ container: HTMLElement, summaryEl: HTMLElement, prevButton: HTMLElement, nextButton: HTMLElement, pagesContainer?: HTMLElement, pageSizeSelect?: HTMLSelectElement }",
          "adapters": "{ dataSource, parseLocation, syncLocation, onStateChange, formatSummary?, announce? }"
        },
        "stateShape": {
          "controllerState": "PAGINATION_CONTROLLER.getUiState() output",
          "shellState": "DOM + listener bindings managed by PAGINATION_SHELL",
          "teardown": "{ destroy: () => void }"
        },
        "mountApi": "mountPaginationSuite({ params, adapters, uiTexts, options }) => { destroy() }"
      },
      "composes": [
        "PAGINATION_CONTRACT",
        "PAGINATION_CONTROLLER",
        "PAGINATION_SHELL"
      ]
    },
    {
      "patternId": "INLINE_BUNDLE_PANEL_SHELL",
      "type": "shell",
      "version": "1.1.0",
      "purpose": "Provide the inline bundle composer drawer around the Available Books grid with consistent triggers, book chips, and form fields.",
      "requiredParams": [
        "container",
        "panelHeading",
        "triggerSelector",
        "bookList",
        "bundleNameInput",
        "bundlePriceInput",
        "recommendedPrice",
        "totalPrice",
        "saveButton",
        "resetButton"
      ],
      "optionalParams": [
        "overlay",
        "closeButton",
        "existingBundleSelect",
        "emptyState",
        "bookRowSelector",
        "pinButton",
        "viewBundleLink"
      ],
      "adapters": {
        "controller": "BundleComposerController instance with subscribe(listener) => unsubscribe and dispatch(action, payload).",
        "formatPrice": "(valueInMinorUnits: number, currency: string) => string",
        "announce": "(message: string, politeness?: 'polite'|'assertive') => void"
      },
      "uiTexts": {
        "panelTitle": "Bundle in progress",
        "emptyState": "Add a book to start a bundle",
        "bundleNameLabel": "Bundle name",
        "bundlePriceLabel": "Bundle price",
        "recommendedPriceLabel": "Recommended price",
        "totalPriceLabel": "Total sale price",
        "saveLabel": "Save bundle",
        "resetLabel": "Clear bundle"
      },
      "a11yNotes": [
        "Use role='region' with aria-label or aria-labelledby=panelHeading so screen readers announce the drawer when it opens.",
        "Focus must move to panelHeading when the drawer opens and return to the triggering book card when it closes.",
        "Recommended and total price blocks should mirror controller output via aria-live=polite so price changes are heard without extra timers.",
        "Ensure remove buttons expose the book title in their accessible name and Clear bundle announces count of items being removed.",
        "Mark invalid inputs with aria-invalid and tie helper text via aria-describedby as soon as validation errors arrive."
      ],
      "testBehaviors": [
        "Opening the panel from any trigger moves focus to panelHeading and toggles aria-expanded on the trigger.",
        "Panel stays visible/pinned when multiple selections exist and collapses only when stateController reports zero selections.",
        "Book chips render in selection order with remove buttons that call controller.dispatch('removeBook', bookId).",
        "Save/Reset buttons reflect disabled/aria-busy state from controller state without desync.",
        "Recommended price placeholder swaps to formatted output using formatPrice() once controller emits values."
      ],
      "docs": {
        "requestShape": {
          "params": "{ container: Element, panelHeading: Element, triggerSelector: string, bookList: Element, bundleNameInput: HTMLInputElement, bundlePriceInput: HTMLInputElement, recommendedPrice: Element, totalPrice: Element }",
          "adapters": "{ controller, formatPrice, announce }",
          "uiTexts": "{ panelTitle?, emptyState?, bundleNameLabel?, bundlePriceLabel?, recommendedPriceLabel?, totalPriceLabel?, saveLabel?, resetLabel? }"
        },
        "stateShape": {
          "isOpen": "boolean",
          "pinned": "boolean",
          "activeBookIds": "string[]",
          "fieldStatus": "{ bundleName: { value: string, error?: string }, bundlePrice: { value: string, error?: string } }",
          "recommendedPriceText": "string",
          "totalPriceText": "string"
        },
        "mountApi": "mountInlineBundlePanel(container, { params, adapters, uiTexts, options }) => { addBook(book, triggerButton), reset(), destroy() }",
        "modulePath": "src/ui/patterns/inline-bundle-panel-shell/index.js"
      }
    },
    {
      "patternId": "INLINE_BUNDLE_COMPOSER_CONTROLLER",
      "type": "controller",
      "version": "1.0.0",
      "purpose": "Manage inline bundle context, pricing, validation, and persistence hooks without forcing navigation away from Available Books.",
      "requiredParams": [
        "currency",
        "pricePrecision",
        "recommendationThreshold"
      ],
      "optionalParams": [
        "bundleId",
        "maxBooks",
        "persistSessionKey",
        "defaultBundleNamePrefix",
        "clock",
        "analytics"
      ],
      "adapters": {
        "fetchPriceRecommendation": "({ bookIds: string[], currency: string }) => Promise<{ recommendedPriceMinor: number, totalSalePriceMinor: number }>",
        "loadBundle": "(bundleId: string) => Promise<{ bundleName: string, bundlePriceMinor: number, bookIds: string[] }>",
        "saveBundle": "(payload: { bundleName: string, bundlePriceMinor: number, bookIds: string[], bundleId?: string }) => Promise<{ bundleId: string }>",
        "persistDraft": "(state: Record<string, any>) => void",
        "onStateChange": "(state: BundleComposerState) => void"
      },
      "uiTexts": {
        "defaultBundleNamePrefix": "Bundle from Available Books",
        "pricePlaceholder": "Enter bundle price",
        "recommendedPendingCopy": "Add another book to see the recommended price",
        "errorDuplicate": "This book is already part of the bundle"
      },
      "a11yNotes": [
        "Expose lastAnnouncedMessage so shells can pipe it directly to aria-live without inferring intent.",
        "Track focusRestoreTarget after destructive actions (clear/reset) so the shell can restore focus predictably.",
        "Emit validationErrors with field-friendly keys so shells may set aria-invalid without string parsing."
      ],
      "testBehaviors": [
        "First addBook() call spawns an empty context with a generated bundleId and stores the triggering book without duplicates.",
        "Recommended/total price calculations only fire when selection count >= recommendationThreshold and collapse back to placeholders when below threshold.",
        "Validation errors block saveBundle() and clear immediately after the field becomes valid.",
        "Reset returns controller state to the initial empty draft while preserving persistSessionKey metadata when provided.",
        "saveBundle() is idempotent; duplicate invocations while isSaving stays true are ignored."
      ],
      "docs": {
        "requestShape": {
          "params": "{ currency: string, pricePrecision: number, recommendationThreshold: number, maxBooks?: number, persistSessionKey?: string, defaultBundleNamePrefix?: string }",
          "adapters": "{ fetchPriceRecommendation, loadBundle, saveBundle, persistDraft?, onStateChange? }",
          "options": "{ debounceMs?: number, analytics?: { track(event, payload) } }"
        },
        "stateShape": {
          "bundleId": "string|null",
          "books": "{ id: string, title: string, salePriceMinor: number }[]",
          "bundleName": "string",
          "bundlePriceMinor": "number|null",
          "recommendedPriceMinor": "number|null",
          "totalSalePriceMinor": "number",
          "validationErrors": "Record<string,string>",
          "isSaving": "boolean",
          "resumeBundleId": "string|null",
          "lastInteraction": "number (timestamp)"
        },
        "mountApi": "createInlineBundleComposerController({ params, adapters, uiTexts, options }) => { addBook(book), removeBook(bookId), updateFields(partial), setExistingBundle(bundleId), reset(), saveBundle(), getState(), subscribe(listener), destroy() }"
      }
    },
    {
      "patternId": "INLINE_BUNDLE_COMPOSER",
      "type": "aggregate",
      "version": "1.0.0",
      "purpose": "Bundle the inline composer shell and controller so list views can mount one factory to add books to bundles, preview pricing, and save without page swaps.",
      "requiredParams": [
        "container",
        "panelHeading",
        "triggerSelector",
        "bookList",
        "bundleNameInput",
        "bundlePriceInput",
        "recommendedPrice",
        "totalPrice",
        "saveButton",
        "currency"
      ],
      "optionalParams": [
        "existingBundleSelect",
        "resetButton",
        "overlay",
        "closeButton",
        "pinButton",
        "viewBundleLink",
        "emptyState",
        "persistSessionKey",
        "maxBooks"
      ],
      "adapters": {
        "fetchPriceRecommendation": "({ bookIds: string[], currency: string }) => Promise<{ recommendedPriceMinor: number, totalSalePriceMinor: number }>",
        "loadBundle": "(bundleId: string) => Promise<{ bundleName: string, bundlePriceMinor: number, bookIds: string[] }>",
        "listExistingBundles": "() => Promise<{ id: string, name: string, bookCount: number }[]>",
        "saveBundle": "(payload: { bundleName: string, bundlePriceMinor: number, bookIds: string[], bundleId?: string }) => Promise<{ bundleId: string }>",
        "linkBooks": "(bundleId: string, bookIds: string[]) => Promise<void>",
        "formatPrice": "(valueInMinorUnits: number, currency: string) => string",
        "toastSuccess": "(message: string, options?: Record<string,any>) => void",
        "toastError": "(message: string, options?: Record<string,any>) => void",
        "announce": "(message: string) => void"
      },
      "uiTexts": {
        "panelTitle": "Bundle in progress",
        "emptyState": "Add a book to start a bundle",
        "existingBundleLabel": "Continue existing bundle",
        "saveLabel": "Save bundle",
        "updateLabel": "Update bundle",
        "clearBundleLabel": "Clear bundle",
        "viewBundleLabel": "View bundle"
      },
      "a11yNotes": [
        "Aggregate must apply aria-live to pricing summaries and toast messages while keeping focus inside the composer during saves.",
        "Expose do-not-change selectors for triggers (#inlineBundleComposer, [data-test='bookAddToBundle']) so codex-tdd can rely on them across topics.",
        "When errors occur the shell should receive focus on an inline error summary before returning focus to the Save button.",
        "Provide aria-controls relationships between triggers and the drawer container for assistive tech context."
      ],
      "testBehaviors": [
        "First Add to bundle trigger mounts the aggregate exactly once and wires controller->shell state without race conditions.",
        "Existing bundle selection hydrates controller state and refreshes shell chips without losing unsaved book selections.",
        "saveBundle() promise resolution shows toastSuccess, passes bundleId to viewBundleLink, and clears state only when the user confirms.",
        "Error paths call toastError, keep the panel open, and leave controller state untouched for retries.",
        "linkBooks() calls happen after saveBundle() resolves to ensure Firestore writes stay ordered."
      ],
      "docs": {
        "requestShape": {
          "params": "{ container, panelHeading, triggerSelector, bookList, bundleNameInput, bundlePriceInput, recommendedPrice, totalPrice, saveButton, currency, existingBundleSelect?, resetButton? }",
          "adapters": "{ fetchPriceRecommendation, loadBundle, listExistingBundles?, saveBundle, linkBooks, formatPrice, toastSuccess, toastError, announce }",
          "uiTexts": "{ panelTitle?, emptyState?, existingBundleLabel?, saveLabel?, updateLabel?, clearBundleLabel?, viewBundleLabel? }"
        },
        "stateShape": {
          "controllerState": "InlineBundleComposerControllerState",
          "shellState": "{ isOpen: boolean, pinned: boolean, chipOrder: string[] }",
          "teardown": "() => void"
        },
        "mountApi": "mountInlineBundleComposer({ params, adapters, uiTexts, options }) => { destroy(), controller, shell }"
      },
      "composes": [
        "INLINE_BUNDLE_PANEL_SHELL",
        "INLINE_BUNDLE_COMPOSER_CONTROLLER"
>>>>>>> Stashed changes
      ]
    }
  ]
}
